export const state = () => ({
  gameSetupState: 0,
  currentGame: {},
  currentGameStatus: false,
  gameHistory: [],
  loggedInStatus: false,
  historyDataFetched: false,
  error: null,
})

export const getters = {
  getCurrentGameStatus(state) {
    return state.currentGameStatus
  },
  getCurrentGame(state) {
    return state.currentGame
  },
  getGameHistory(state) {
    return state.gameHistory
  },
  getLoggedInStatus(state) {
    return state.loggedInStatus
  },
  getHistoryDataFetched(state) {
    return state.historyDataFetched
  },
  getError(state) {
    return state.error
  },
}

export const mutations = {
  SET_CURRENT_GAME_STATUS_FALSE(state) {
    state.currentGameStatus = false
  },
  SET_CURRENT_GAME_STATUS_TRUE(state) {
    state.currentGameStatus = true
  },
  ADD_BASKET(state, scoreObject) {
    state.currentGame.baskets.push(scoreObject)
  },
  EDIT_BASKET(state, index, scoreObject) {
    state.currentGame.baskets[index] = scoreObject
  },
  ADD_CURRENT_GAME_TO_HISTORY(state) {
    state.gameHistory.push(state.currentGame)
  },
  CLEAR_CURRENT_GAME(state) {
    //  state.currentGame = {
    //    id: null,
    //    date: null,
    //    course: null,
    //    players: [],
    //    baskets: [],
    //  }
    state.currentGame = null
  },
  CREATE_NEW_GAME(state, gameObject) {
    state.currentGame = gameObject
  },
  SET_GAME_HISTORY(state, historyArray) {
    state.gameHistory = historyArray
  },
  SET_HISTORY_DATA_FETCHED(state, boolean) {
    state.historyDataFetched = boolean
  },
  SET_LOGGED_IN_STATUS(state, boolean) {
    state.loggedInStatus = boolean
  },
  SET_ERROR(state, error) {
    state.error = error
  },
  CLEAR_ERROR(state) {
    state.error = null
  },
}

export const actions = {
  /**
   * Automatically called on server side to pre-populate the Vuex store.
   * First arg is Vuex context, second arg would be Nuxt context
   * More info: https://nuxtjs.org/docs/concepts/nuxt-lifecycle/
   */
  async nuxtServerInit(context) {
    try {
      const endpoint =
        process.env.baseURL + '/.netlify/functions/fetch-game-history'
      const response = await this.$axios.$get(endpoint)
      context.commit('SET_GAME_HISTORY', response.msg)
      context.commit('SET_HISTORY_DATA_FETCHED', true)
      return true
    } catch (error) {
      context.commit('SET_ERROR', error)
      context.commit('SET_HISTORY_DATA_FETCHED', false)
      return false
    }
  },
  // async restoreCurrentGame() {
  //    // reach out to DB?
  // }

  /* async */
  // createNewGame({ state }, ) {
  //    const gameObject = {
  //       // id: state.gameHistory.length,
  //       course:

  //    }
  // }
  clearGame(context) {
    context.commit('CLEAR_GAME')
  },
  startNewGame(context, { course, players }) {
    /** do some validation */
    const newGame = {
      course,
      date: Date.now(),
      players,
      baskets: [],
    }
    context.commit('CREATE_NEW_GAME', newGame)
    context.commit('SET_CURRENT_GAME_STATUS_TRUE')
  },
  finishCurrentGame(context) {
    context.commit('ADD_CURRENT_GAME_TO_HISTORY')
    context.commit('SET_CURRENT_GAME_STATUS_FALSE')
  },
  addBasket(context, payload) {
    context.commit('ADD_BASKET', payload)
    /**
    * const basket = {
      hole: 1,
    }
    for (let i = 0; i < players.length; i++) {
      basket[players[i]] = 0
    }
    */
  },
  setGameHistory(context, payload) {
    context.commit('SET_GAME_HISTORY', payload)
  },
  setLoggedInStatus(context, boolean) {
    context.commit('SET_LOGGED_IN_STATUS', boolean)
  },
}

/**
 * Game object:
 * {
 *    id: <Number> (autogenerated)
 *    course_name: <String>
 *    date: <String> (Date)
 *    players: <Array[String]>
 *    baskets: [
 *       {
 *          BasketName: 1 (String to accomodate stuff like '8a')
 *          Scores: [
 *          {Name1: 3}
 *          {Name2: 4}
 *          ]
 *          Par: 3 (default)
 *          Notes?
 *       },
 *       {
 *          Name: 2,
 *          Name1: 4
 *          Name2: 3
 *          Par: 3
 *       },
 *       ...
 *    ]
 * }
 *
 */
